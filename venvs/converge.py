"""
Converge the set of installed virtualenvs.

"""
from datetime import datetime
import subprocess
import sys

from filesystems.exceptions import FileExists, FileNotFound
from tqdm import tqdm
import click
import toml

from venvs import __version__
from venvs._config import Config
from venvs.common import _FILESYSTEM, _LINK_DIR, _ROOT


_MODULE_WRAPPER = """\
#!{python}
# Auto-generated by venvs v{version} on {now}.
# Don't modify this file, it may be replaced when re-converging.
import os
import sys
# No runpy.run_module because of https://bugs.python.org/issue37941 ...
argv = [sys.executable, "-m", "{name}"] + sys.argv[1:]
os.execvp(argv[0], argv)
"""


def _fail(virtualenv):
    raise


def _do_not_fail(virtualenv):
    sys.stderr.write("Converging {!r} failed!\n".format(virtualenv))


@_FILESYSTEM
@_LINK_DIR
@_ROOT
@click.option(
    "--fail-fast", "handle_error",
    flag_value=_fail,
    help="Fail if any virtualenv cannot be converged.",
)
@click.option(
    "--no-fail-fast", "handle_error",
    default=True,
    flag_value=_do_not_fail,
    help="Do not fail if a virtualenv cannot be converged.",
)
def main(filesystem, locator, link_dir, handle_error):
    """
    Converge the configured set of tracked virtualenvs.
    """
    versions = {}

    for name, config in _loop(
        config=Config.from_locator(filesystem=filesystem, locator=locator),
        handle_error=handle_error,
    ):
        python = config["python"]
        if python in versions:
            config["sys.version"] = versions[python]
        else:
            config["sys.version"] = versions[python] = subprocess.check_output(
                [python, "--version"],
                stderr=subprocess.STDOUT,
            ).decode("ascii")

        virtualenv = locator.for_name(name=name)
        existing_config_path = virtualenv.path / "installed.toml"

        try:
            existing_config = filesystem.get_contents(existing_config_path)
        except FileNotFound:
            virtualenv.create(python=python)
        else:
            if toml.loads(existing_config) == config:
                continue
            virtualenv.recreate_on(filesystem=filesystem, python=python)

        try:
            virtualenv.install(
                packages=config["install"],
                requirements=config["requirements"],
            )
        except Exception:
            handle_error(virtualenv)
            continue

        for link in config["link"]:
            name, _, to = link.partition(":")
            _link(
                source=virtualenv.binary(name=name),
                to=link_dir.descendant(to or name),
                filesystem=filesystem,
            )

        for each in config["link-module"]:
            name, _, to = each.partition(":")
            filesystem.create_with_contents(
                link_dir.descendant(to or name),
                _MODULE_WRAPPER.format(
                    python=virtualenv.binary(name="python"),
                    name=name,
                    version=__version__,
                    now=datetime.now(),
                ),
            )

        filesystem.set_contents(
            existing_config_path,
            mode="t",
            contents=toml.dumps(config),
        )


def _loop(config, handle_error):
    progress = tqdm(iterable=config, total=len(config), unit="venv")
    iterable = iter(progress)
    while True:
        try:
            name, config = next(iterable)
        except StopIteration:
            return
        except Exception:
            handle_error(None)
        else:
            progress.set_description(name)
            yield name, config


def _link(source, to, filesystem):
    """
    Link the given binary, replacing broken symlinks and erroring if existing.
    """

    try:
        filesystem.link(source=source, to=to)
    except FileExists as error:
        if filesystem.realpath(error.value) == filesystem.realpath(source):
            return
        if filesystem.exists(to):
            raise
        filesystem.remove(to)
        filesystem.link(source=source, to=to)
